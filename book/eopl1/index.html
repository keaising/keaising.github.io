<!DOCTYPE html>
<html lang="zh-Hans" class="han-la">

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>第一章 归纳的数据集 - 流水沉微</title>
    <link rel="stylesheet" href="/css/normalize.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/syntax.css">
    <link rel="stylesheet" href="/css/kitto.css">
    <script src="/js/anchor.min.js"></script>
    <script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
    <script src="/js/text-autospace.js"></script>
</head>

<body>
    <div class="content width">
        <div class="top-header">
  <a class="site-title" href="http://shuxiao.wang">
    流水沉微
  </a>

  
  
  <div class="nav-body">
    
    
    <a class="nav-item " href="/posts/">
      
      <span>Posts</span>
    </a>
    
    
    
    <a class="nav-item " href="/cloud/">
      
      <span>Cloud</span>
    </a>
    
    
    
    <a class="nav-item " href="/eureka/">
      
      <span>Eureka!</span>
    </a>
    
    
  </div>
  
</div>

        <div>
            


<div class="Subhead">
    <div class="Subhead-heading">
        <h1>第一章 归纳的数据集</h1>
    </div>
</div>




<article>
    
    <div class="true-content">
        <p>本章介绍了一些基本的编程工具，这些工具在后续编写解释器(interpreters)、检查器(checkers)和类似组成编程语言核心处理器(processor)之类的程序的时候需要用到</p>
<p>由于一门语言中的语法(syntax)通常都是嵌套(nested)或者树状结构(treelike structure)，故递归在我们将使用的技术中将占据核心位置。第1.1节和第1.2节介绍了用归纳法来描述(specify)数据结构的方法，并揭示了这种描述方法将如何指导我们编写递归的程序。第1.3节阐述了如何将该方法扩展到更加复杂的问题中。最后，本章将以大量的练习作为结尾，这些练习才是本章的核心内容，他们将为你提供足够的经验，去掌握递归编程的思想(the technique of recursive programming)，而这思想，正是本书其他部分的基石。</p>
<h2 id="11-递归得描述specified数据">1.1 递归得描述(specified)数据</h2>
<p>为一个过程(procedure)编写代码时，我们必须准确得知道该过程的参数的类型、以及该过程的返回值的类型。通常这些值都是复杂类型。在本节，我们将介绍描述这些值的一般方法。</p>
<h3 id="111-归纳描述法inductive-specification">1.1.1 归纳描述法(Inductive Specification)</h3>
<p><em>归纳描述法</em> 是一个描述数据的有力方法。为了展示这一点，我们将用它来描述自然数<span class="Math">\(N={0,1,2,...}\)</span>的一个真子集<span class="Math">\(S\)</span></p>
<dl>
<dt><strong>定义1.1.1</strong></dt>
<dd>自然数<span class="Math">\(n\)</span>属于集合<span class="Math">\(S\)</span>，当且仅当
<ol>
<li><span class="Math">\(n=0\)</span>，或者</li>
<li><span class="Math">\(n-3 \in S\)</span></li>
</ol>
</dd>
</dl>
<p>让我们看看如何使用这个定义来决定哪些自然数属于集合<span class="Math">\(S\)</span>，我们知道<span class="Math">\(0 \in S\)</span>，那么<span class="Math">\(3 \in S\)</span>，因为<span class="Math">\((3-3)=0\)</span>且<span class="Math">\(0 \in S\)</span>。类似可知<span class="Math">\(6 \in S\)</span>，因为<span class="Math">\((6-3)=0\)</span>且<span class="Math">\(3 \in S\)</span>。将该推演过程继续下去，我们可以得到结论：所有的<span class="Math">\(3\)</span>的倍数都属于集合<span class="Math">\(S\)</span>。</p>
<p>那么其他的自然数呢？<span class="Math">\(1 \in S\)</span>是否成立呢？我们知道<span class="Math">\(1 \ne 0\)</span>，因此不满足条件1；此外<span class="Math">\((1-3)=-2\)</span>，这不是一个自然数也就不属于集合<span class="Math">\(S\)</span>，因此不满足条件2。故<span class="Math">\(1\)</span>不满足任何一个条件，<span class="Math">\(1 \not \in S\)</span>，类似的，<span class="Math">\(2 \not \in S\)</span>。那么<span class="Math">\(4\)</span>呢？<span class="Math">\(4 \in S\)</span>只有在<span class="Math">\(1 \in S\)</span>成立的情况下成立，但是<span class="Math">\(1 \not \in S\)</span>，所以<span class="Math">\(4 \not \in S\)</span>。类似地，我们可以得到这样的结论：如果<span class="Math">\(n\)</span>是一个自然数且它不是<span class="Math">\(3\)</span>的倍数，那么<span class="Math">\(n \not \in S\)</span></p>
<p>以上讨论可以得到结论：<span class="Math">\(S\)</span>是这样的自然数的集合：<span class="Math">\(3\)</span>的倍数</p>
<p>我们可以用这个定义来写一个判断自然数<span class="Math">\(n\)</span>是否属于集合<span class="Math">\(S\)</span>的过程(procedure)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scheme" data-lang="scheme"><span class="line"><span class="cl"><span class="nv">in-S?</span> <span class="nv">:</span> <span class="nv">N</span> <span class="nv">-&gt;</span> <span class="nv">Bool</span>
</span></span><span class="line"><span class="cl"><span class="nv">usage:</span> <span class="p">(</span><span class="nf">in-S?</span> <span class="nv">n</span><span class="p">)</span> <span class="nv">=</span> <span class="no">#t</span> <span class="k">if </span><span class="nv">n</span> <span class="nv">is</span> <span class="nv">in</span> <span class="nv">S,</span> <span class="no">#f</span> <span class="nv">otherwise</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="k">define </span><span class="nv">in-S?</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">zero? </span><span class="nv">n</span><span class="p">)</span> <span class="no">#t</span>
</span></span><span class="line"><span class="cl">            <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt;= </span><span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">(</span><span class="nf">in-S?</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">3</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="no">#f</span><span class="p">))))</span>
</span></span></code></pre></div><p>这里我们根据定义用Scheme写了一个递归过程。其中<code>in-S? : N -&gt; Bool</code>是一个批注(comment)，称为该过程的<em>契约(contract)</em> ，它表示<code>in-S?</code>被设计为这样一个过程：以一个自然数作为入参并产生一个布尔值作为出参。这样的批注对读写代码都是很有帮助的</p>
<p>为了判断<span class="Math">\(n \in S\)</span>是否成立，我们首先判断<span class="Math">\(n=0\)</span>是否成立，如果后者成立，则前者也成立。否则我们需要看<span class="Math">\(n-3 \in S\)</span>是否成立，为了判断<span class="Math">\(n-3 \in S\)</span>是否成立，我们先要检查<span class="Math">\((n-3) \ge 0\)</span>是否成立。如果成立的话，我们就可以使用我们已有的过程逻辑来判断它是否属于集合<span class="Math">\(S\)</span>，如果不成立，那么<span class="Math">\(n\)</span>不可能属于集合<span class="Math">\(S\)</span></p>
<p>下面是另一种集合<span class="Math">\(S\)</span>的定义</p>
<dl>
<dt><strong>定义1.1.2</strong></dt>
<dd>定义集合<span class="Math">\(S\)</span>为包含于自然数<span class="Math">\(N\)</span>且满足下列两个性质的最小集合:
<ol>
<li><span class="Math">\(0 \in S\)</span>，且</li>
<li>如果<span class="Math">\(n \in S\)</span>，那么<span class="Math">\(n&#43;3 \in S\)</span></li>
</ol>
</dd>
</dl>
<p>一个“最小集合”是指满足条件1和条件2且是任何满足条件1和条件2的集合的子集。很容易看出这样的集合只有一个：假设存在<span class="Math">\(S_1\)</span>和<span class="Math">\(S_2\)</span>都满足条件1和条件2且都是最小集合，那么<span class="Math">\(S_1 \subseteq S_2 \)</span>（因为<span class="Math">\(S_1\)</span>是最小集合）且<span class="Math">\(S_2 \subseteq S_1 \)</span>（因为<span class="Math">\(S_2\)</span>也是最小集合），因此<span class="Math">\(S_1=S_2\)</span>。我们需要这个额外条件，否则会有许多集合满足以上两个条件（参见练习1.3）</p>
<p>另外还有一种定义的写法：</p>
<div class="Math Math-Formula">\(\dfrac{}{0 \in S}\qquad\)</div>
<div class="Math Math-Formula">\(\dfrac{n \in S}{(n&#43;3) \in S}\qquad\)</div>
<p>这只是前面写法的一种简写形式，每一个条目称为一个“推演规则”，或者简称为一个“规则”，横线读作“如果&hellip;那么&hellip;”，横线上半部分称为“假设/先行词”，横线下半部分称为“结论/推断”。当存在两个以上假设时，他们之间默认用“且”连接（例如<strong>定义1.1.5</strong>）。没有假设的规则称为“公理”，通常，公理的横线会省略不写，比如：</p>
<div class="Math Math-Formula">\(0 \in S\)</div>
<p>该公理的意思是：自然数<span class="Math">\(n\)</span>在集合<span class="Math">\(S\)</span>中，当且仅当语句<span class="Math">\(n \in S\)</span>可以在有限次数内使用推演规则从公理推导出。这个解释天然得保证了集合<span class="Math">\(S\)</span>是在规则范围内闭合的所有集合里的最小集合</p>
<p>这些定义全都描述了同样的事。第一个版本我们称为「自上而下」法，第二个版本称为「自下而上」法，而第三个版本称为「推演规则」法，现在我们来试试将这些规则应用到其他例子</p>
<dl>
<dt><strong>定义1.1.3 (整数数列，自上而下)</strong></dt>
<dd>一个<code>Scheme list</code>是一个<code>List-of-Int</code>，当且仅当：
<ol>
<li>它是一个空数列，或者</li>
<li>它是一个car是整数、cdr是一个整数数列的序对(pair)</li>
</ol>
</dd>
</dl>
<p>在这里我们使用<code>Int</code>表示全体整数的集合，用<code>List-of-Int</code>表示全部<code>整数数列</code>的集合</p>
<dl>
<dt>译者注：</dt>
<dd>关于序对(pair)、car、cdr可以阅读<a href="https://people.csail.mit.edu/jaffer/r5rs/Pairs-and-lists.html">Pairs and lists - Revised(5) Scheme</a>。以下关于简单的Scheme语法不再提示</dd>
</dl>
<p>接下来再看另一个定义</p>
<dl>
<dt><strong>定义1.1.4 (整数数列，自下而上)</strong></dt>
<dd>集合<code>List-of-Int</code>在满足以下两个条件时，就是最小的<code>Scheme List</code>集合
<ol>
<li><span class="Math">\(() \in List-of-Int\)</span>，且</li>
<li>如果<span class="Math">\(n \in Int\)</span>且<span class="Math">\(l \in List-of-Int\)</span>，那么<span class="Math">\((n . l) \in List-of-Int\)</span></li>
</ol>
</dd>
</dl>
<p>这里我们使用占位符<code>.</code>来表示Scheme语言中<code>cons</code>操作的结果。<code>(n . l)</code>表示一个Scheme语言中的一个序对，在这个序对中，<code>car</code>是<code>n</code>，<code>cdr</code>是<code>l</code></p>
<dl>
<dt><strong>定义1.1.5 (整数数列，推演规则)</strong></dt>
<dd><div class="Math Math-Formula">\(() \in List-of-Int\)</div>
<div class="Math Math-Formula">\(\dfrac{n \in Int \hspace{2em} l \in List-of-Int}{(n \hspace{.5em} . \hspace{.5em} l) \in List-of-Int}\qquad\)</div></dd>
</dl>
<p>这3个定义是相等的。我们接下来演示一下如何用他们来生成<code>List-of-Int</code>中的一些元素</p>
<ol>
<li><code>()</code>是一个整数列，因为它满足定义1.1.4的属性1或者是满足定义1.1.5的第一个规则</li>
<li><code>(14 . ())</code>是一个整数列，根据定义1.1.4的属性2可知，因为<code>14</code>是一个整数，而<code>()</code>是一个整数列，我们可以将这个推论写作是<code>List-of-Int</code>的第二条规则的一个实例 
<div class="Math Math-Formula">\(\dfrac{14 \in Int \hspace{2em} () \in List-of-Int}{(14 \hspace{.5em} . \hspace{.5em} ()) \in List-of-Int}\qquad\)</div></li>
<li><code>(3 . (14 . ()))</code>是一个整数列，根据属性2可知，因为<code>3</code>是一个整数，而<code>(14 . ())</code>是一个整数列，我们也可以将这个推演过程写作<code>List-of-Int</code>的第二条规则的一个实例
<div class="Math Math-Formula">\(\dfrac{3 \in Int \hspace{2em} (14 \hspace{.5em} . \hspace{.5em} ()) \in List-of-Int}{(3 \hspace{.5em} . \hspace{.5em} (14 \hspace{.5em} . \hspace{.5em} ())) \in List-of-Int}\qquad\)</div></li>
<li><code>(-7 . (3 . (14 . ())))</code>是一个整数列，根据属性2可知，因为<code>-7</code>是一个整数，而<code>(3 . (14 . ()))</code>是一个整数列，这次我们同样将这个推演过程写作<code>List-of-Int</code>的第二条规则的一个实例
<div class="Math Math-Formula">\(\dfrac{-7 \in Int \hspace{2em} (3 \hspace{.5em} . \hspace{.5em} (14 \hspace{.5em} . \hspace{.5em} ())) \in List-of-Int}{(-7 \hspace{.5em} . \hspace{.5em} (3 \hspace{.5em} . \hspace{.5em} (14 \hspace{.5em} . \hspace{.5em} ()))) \in List-of-Int}\qquad\)</div></li>
<li>如果一个数列也是这样构建的话，那就是一个整数列</li>
</ol>
<p>将上面的点表示法转换成列表表示法，可以看到<code>()</code>、<code>(14)</code>、<code>(3 14)</code>、<code>(-7 3 14)</code>都包含于<code>List-of-Int</code>。我们也可以将规则全部合起来，得到整个<span class="Math">\((-7 \hspace{.5em} . \hspace{.5em} (3 \hspace{.5em} . \hspace{.5em} (14 \hspace{.5em} . \hspace{.5em} ()))) \in List-of-Int\)</span>因果链的全景图。下面这个树状图被称为<em>派生树</em>或者<em>演绎树</em></p>
<div class="Math Math-Formula">\(\begin{align} 14 \in N \hspace{2em} () &amp;\in List-of-Int \\ \rule{3.5cm}{.6pt} &amp; \rule{3.5cm}{.6pt} \\ 3 \hspace{.5em} . \hspace{.5em} (14 \hspace{.5em} . \hspace{.5em} ())) &amp;\in List-of-Int \\ \rule{6cm}{.6pt} &amp; \rule{3.5cm}{.6pt} \\ -7 \in N \hspace{2em} (3 \hspace{.5em} . \hspace{.5em} (14 \hspace{.5em} . \hspace{.5em} ())) &amp;\in List-of-Int \\ \rule{6cm}{.6pt} &amp; \rule{3.5cm}{.6pt} \\ (-7 \hspace{.5em} . \hspace{.5em} (3 \hspace{.5em} . \hspace{.5em} (14 \hspace{.5em} . \hspace{.5em} ()))) &amp; \in List-of-Int \end{align}\)</div>
<dl>
<dt>练习1.1 [*]</dt>
<dd>写出下列集合的归纳法定义。每个定义都要写3种类型(自上而下，自下而上，推演规则)，并使用你所写的规则，举出每个集合的示例数据
<ol>
<li><span class="Math">\({3n&#43;2 \hspace{.5em} | \hspace{.5em} n \in N}\)</span></li>
<li><span class="Math">\({2n&#43;3m&#43;1 \hspace{.5em} | \hspace{.5em} n,m \in N}\)</span></li>
<li><span class="Math">\({(n,2n&#43;1) \hspace{.5em} | \hspace{.5em} n \in N}\)</span></li>
<li><span class="Math">\({(n,n^2) \hspace{.5em} | \hspace{.5em} n \in N}\)</span> 
不要在定义的规则中使用平方，一点小提示，想想这个方程 <span class="Math">\((n&#43;1)^2 = n^2&#43;2n&#43;1 \)</span></li>
</ol>
</dd>
<dt>练习1.2 [**]</dt>
<dd>根据以下规则分别可以得到什么样的集合？并阐述理由
<ol>
<li><span class="Math">\((0,1) \in S \hspace{3em} \dfrac{(n, k) \in S}{(n&#43;1,k&#43;7) \in S}\qquad\)</span></li>
<li><span class="Math">\((0,1) \in S \hspace{3em} \dfrac{(n, k) \in S}{(n&#43;1,2k) \in S}\qquad\)</span></li>
<li><span class="Math">\((0,0,1) \in S \hspace{3em} \dfrac{(n, i, j) \in S}{(n&#43;1,j,i&#43;j) \in S}\qquad\)</span></li>
<li>[***] <span class="Math">\((0,1,0) \in S \hspace{3em} \dfrac{(n, i, j) \in S}{(n&#43;1,i&#43;2,i&#43;j) \in S}\qquad\)</span></li>
</ol>
</dd>
<dt>练习1.3 [*]</dt>
<dd>找到满足以下条件的自然数集合<code>T</code>：
<ol>
<li><span class="Math">\(0 \in T\)</span></li>
<li>对任何<span class="Math">\(n \in T\)</span>，都有<span class="Math">\(n&#43;3 \in T\)</span></li>
<li><span class="Math">\(T \neq S\)</span>，其中<span class="Math">\(S\)</span>是定义1.1.2中的集合</li>
</ol>
</dd>
</dl>
<h3 id="112-用语法grammars定义集合">1.1.2 用语法(Grammars)定义集合</h3>
<p>之前的例子非常的直观，但是很容易想象到，在处理更复杂的数据类型的时候，描述过程会变得相当的笨重。为了作出改进，我们将展示如何用<em>语法</em>来描述集合。语法一般常用于描述字符串集合，但我们同样能用它来定义数值集合。比如我们可以用如下语法来定义<span class="Math">\(List-of-Int\)</span></p>
<div class="Math Math-Formula">\(\begin{align} List-of-Int &amp;::= () \\ List-of-Int &amp;::= (Int \hspace{.5em} . \hspace{.5em} List-of-Int) \end{align}\)</div>
<p>由于定义1.1.4有两个属性，对应得这里有两条规则。第一条规则意味着空数组包含于<code>List-ofInt</code>，第二条规则说明了如果<code>n</code>在集合<code>Int</code>中、<code>l</code>在集合<code>List-of-Int</code>中，那么<code>(n . l)</code>在集合<code>List-of-Int</code>中，这两条规则的组合被称为一个<em>语法</em></p>
<p>现在我们来仔细看看语法的定义，在定义中有如下元素：</p>
<ul>
<li>
<p><strong>非终结性符号</strong>：非终结性符号是指那些被定义的集合的名字。在上面的例子中只有一个这样的集合，但通常来说，一般都会有好几个被定义的集合，这些集合有时候也被称为<strong>句法范畴</strong>。方便起见，我们约定对集合和非终结性符号的名字使用大写名字，在引用他们中的元素时使用小写名字。听起来很复杂但是一看例子就明白了，比如：<span class="Math">\(Expression\)</span>是 非终结的，所以我们写作<span class="Math">\(e \in Expression\)</span>或者<code>e is an expression.</code> 另一种惯用约定是巴科斯范式(Backus-Naur Form)，或者简称BNF，写法是在单词两端写箭头，比如：<span class="Math">\(&lt;expression&gt;\)</span></p>
</li>
<li>
<p><strong>终结性符合</strong>：比如以下符合：<code>. ( )</code>，一般会用等宽字体来写，比如<code>lambda</code></p>
</li>
<li>
<p><strong>Production</strong>：一条规则就是一个production(产品)。每个production分为左右两侧，左侧是一个非终结性符合，右侧是终结性符号和非终结性符号。左右两侧由符号<code>::=</code>分隔，读作<em>是</em>。右侧内容阐明了根据其他句法范畴和终结性符号(比如左括号、右括号和句号)来构造句法范畴成员的方法</p>
</li>
</ul>
<p>有时候，如果从上下文中已经可以得到足够清晰的意义，production中的部分句法范畴也会不进行定义，比如<code>Int</code></p>
<p>语法经常会用使用符号缩写进行编写。如果一个production的左侧内容跟上一个production的左侧内容一致，推荐直接把左侧内容省略，比如：</p>
<div class="Math Math-Formula">\(\begin{align} List-of-Int &amp;::= () \\ &amp;::= (Int \hspace{.5em} . \hspace{.5em} List-of-Int) \end{align}\)</div>
<p>也可以只写一次<code>::=</code>，用一个特殊的<code>|</code>符号将右侧的两行内容分隔，比如：</p>
<div class="Math Math-Formula">\(\begin{align} List-of-Int ::= () \hspace{.5em} | \hspace{.5em} (Int \hspace{.5em} . \hspace{.5em} List-of-Int) \end{align}\)</div>
<p>还有一种缩写形式叫<em>Kleene star</em>(克林星)，用<span class="Math">\(\{...\}^*\)</span>符号来表示</p>

    </div>

    <div class="page-info">
        <div>
            

<div>
    
</div>



<div>
    <a href='/tags/programming-language' class="tags-url">
        <span class="tags">Programming Language</span>
    </a>
</div>

<div>
    <a href='/tags/scheme' class="tags-url">
        <span class="tags">Scheme</span>
    </a>
</div>

<div>
    <a href='/tags/eopl' class="tags-url">
        <span class="tags">EOPL</span>
    </a>
</div>



        </div>
        
            
                <div class="publish-date">
                    <span
                        title="Lastmod: 2019-11-19. Published at: 2019-11-19.">
                        19 Nov 2019
                    </span>
                </div>
            
        
    </div>
</article>





        </div>
        <div id="footer" class="pt-2 pb-3 bg-white text-center">
            

  <span class="text-small text-gray">
    

    Powered by the
    <a href="https://github.com/keaising/kitto" class="link-gray-dark">Kitto</a> theme for
    <a href="https://gohugo.io" class="link-gray-dark">Hugo</a>.
  </span>


        </div>
    </div>

    
    <script>
        anchors.add();
    </script>
    <script>
        anchors.options = {
            placement: 'left',
        };
        anchors.add();
        anchors.add(".tag-title-left");
    </script>
    <script src="/js/mathjax.js"></script>
</body>

</html>